## Hello, Cargo!

<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
_dependencies_.)
-->
CargoはRustのビルドシステムおよびパッケージマネージャーです。
ほとんどのRustaceanたちはこのツールを使ってRustプロジェクトを管理します。
なぜなら、Cargoはコードのビルド、コードが依存するライブラリのダウンロード、そしてそれらのライブラリのビルドなど、多くのタスクをこなしてくれるからです。
（コードが必要としているライブラリを _依存関係(dependencies)_ と呼びます）

<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. If we had built the “Hello, world!” project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
これまで書いたような最もシンプルなRustプログラムには依存関係がありません。
もし仮に「Hello, world!」プロジェクトをCargoで作成していた場合、Cargoの中でもコードのビルドを担当する部分しか使用しなかったでしょう。
より複雑なRustプログラムを書くようになるにつれて、依存関係も追加していくことになります。
Cargoを使ってプロジェクトを開始すれば、依存関係の追加をはるかに簡単に行えるようになります。

<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation] section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following in your terminal:
-->
ほとんどのRustプロジェクトがCargoを使用しているため、この本の残りの部分ではあなたもCargoを使用していることを前提に進めます。
[「インストール」][installation]節で説明した公式インストーラを使用してRustをインストールした場合、Cargoはすでにインストールされています。
他の方法でRustをインストールした場合は、以下のコマンドをターミナルに入力してCargoがインストールされているか確認してください。

```console
$ cargo --version
```

<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
バージョン番号が表示されれば、Cargoはインストールされています！
もし `コマンドが見つかりません` のようなエラーが表示された場合は、あなたが選んだインストール方法に関するドキュメントを見て、Cargoを個別にインストールする方法を確認してください。

<!--
### Creating a Project with Cargo
-->
### Cargoを使用してプロジェクトを作成する

<!--
Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your _projects_ directory
(or wherever you decided to store your code). Then, on any operating system,
run the following:
-->
Cargoを使用して新しいプロジェクトを作成し、最初の「Hello, world!」プロジェクトとの違いを見てみましょう。
まず、再び _projects_ ディレクトリ（またはあなたがコードを保存すると決めた場所）に移動します。
そして、使用しているオペレーティングシステムによらず以下のコマンドを実行します。

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

<!--
The first command creates a new directory and project called _hello_cargo_.
We’ve named our project _hello_cargo_, and Cargo creates its files in a
directory of the same name.
-->
最初のコマンドは、 新しいディレクトリを作成し、 *hello_cargo* という名前のプロジェクトを作成します。
プロジェクト名を *hello_cargo* と名付けたので、Cargoはそれと同名のディレクトリに必要なファイルを作成します。

<!--
Go into the _hello_cargo_ directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a _Cargo.toml_ file and a
_src_ directory with a _main.rs_ file inside.
-->
*hello_cargo* ディレクトリに移動し、ファイルを一覧表示してください。
Cargoによって2つのファイルと1つのディレクトリが生成されたことを確認できるはずです。
具体的には、_Cargo.toml_ ファイルと、 _src_ ディレクトリ内にある _main.rs_ ファイルです。

<!--
It has also initialized a new Git repository along with a _.gitignore_ file.
Git files won’t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->
また、Cargoは新しいGitリポジトリを初期化し、 _.gitignore_ ファイルも作成しています。
もし既存のGitリポジトリ内で`cargo new`を実行した場合、Git関連のファイルは生成されません。
`cargo new --vcs=git`を使用することでこの動作を上書きできます。

<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
> 注: Gitは一般的なバージョン管理システムです。
> `--vcs`フラグを使うことで、`cargo new`が異なるバージョン管理システムを使用したり、バージョン管理システムを何も使用しないようにしたりできます。
> 利用可能なオプションを確認するには`cargo new --help`を実行してください。

<!--
Open _Cargo.toml_ in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
_Cargo.toml_ をお好みのテキストエディタで開いてください。
以下のリスト1-2のコードに似た内容になっているはずです。

<!--
<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

</Listing>
-->
<Listing number="1-2" file-name="Cargo.toml" caption="`cargo new`によって生成された *Cargo.toml* の内容">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

</Listing>

<!--
This file is in the [_TOML_][toml] (_Tom’s Obvious, Minimal
Language_) format, which is Cargo’s configuration format.
-->
このファイルは [_TOML_][toml]（Tom’s Obvious, Minimal Language）フォーマットで書かれており、Cargoの設定フォーマットです。

<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
最初の行の `[package]` はセクションの見出しで、以降の記述がパッケージの設定であることを示しています。
このファイルに情報を追加するごとに、他のセクションを追加していくことになります。

<!--
The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the `edition` key in [Appendix E][appendix-e].
-->
次の3行ではCargoがプログラムをコンパイルするために必要な設定情報を指定しています。
具体的には、名前、バージョン、および使用するRustのエディションです。
`edition`キーについては[Appendix E][appendix-e]で詳しく説明します。

<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
_crates_. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
最後の行の`[dependencies]`は、プロジェクトの依存関係をリストするセクションの開始を示しています。
Rustでは、コードのパッケージは _クレート(crates)_ と呼ばれます。
このプロジェクトでは他のクレートは必要ありませんが、Chapter 2の最初のプロジェクトで必要となるので、そのときにこのdependenciesセクションを使います。

<!--
Now open _src/main.rs_ and take a look:
-->
それでは _src/main.rs_ を開いてみましょう。

<!--
<span class="filename">Filename: src/main.rs</span>
-->
<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

<!--
Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our project and the
project Cargo generated are that Cargo placed the code in the _src_ directory
and we have a _Cargo.toml_ configuration file in the top directory.
-->
Cargo は、私たちが リスト 1-1 で書いたのと同じ「Hello, world!」プログラムを生成してくれました！
これまでのところ、私たちのプロジェクトと Cargo が生成したプロジェクトの違いは、
Cargo がコードを _src_ ディレクトリに配置し、トップディレクトリに _Cargo.toml_ 設定ファイルを作成している点です。

<!--
Cargo expects your source files to live inside the _src_ directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
Cargo は、ソースファイルが `src` ディレクトリ内にあることを期待します。
プロジェクトのトップレベルディレクトリに置くのは、README ファイル、ライセンス情報、設定ファイル、その他コードに関係ないあらゆるものだけです。
Cargo を使うことで、プロジェクトを整理整頓できます。
すべてのものにそれぞれの場所があり、すべてが実際にその場所に置かれています。

<!--
If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the _src_ directory and create an appropriate _Cargo.toml_
file. One easy way to get that _Cargo.toml_ file is to run `cargo init`, which
will create it for you automatically.
-->
もし、我々が「Hello, world!」プロジェクトで行ったように Cargo を使用していないプロジェクトを始めた場合、そのプロジェクトを Cargo を使うプロジェクトに変換することができます。
プロジェクトのコードを _src_ ディレクトリに移動し、適切な _Cargo.toml_ ファイルを作成します。
その _Cargo.toml_ ファイルを簡単に作成する方法の一つが `cargo init` コマンドを実行することで、 _Cargo.toml_ ファイルを自動的に生成してくれます。

<!--
### Building and Running a Cargo Project
-->
### Cargoプロジェクトのビルドと実行

<!--
Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your _hello_cargo_ directory, build your project by
entering the following command:
-->
では、Cargoを使って「Hello, world!」プログラムをビルドして実行すると何が違うのかを見てみましょう！
_hello_cargo_ ディレクトリから、次のコマンドを入力してプロジェクトをビルドします：

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

<!--
This command creates an executable file in _target/debug/hello_cargo_ (or
_target\debug\hello_cargo.exe_ on Windows) rather than in your current
directory. Because the default build is a debug build, Cargo puts the binary in
a directory named _debug_. You can run the executable with this command:
-->
このコマンドは、実行可能ファイルをカレントディレクトリではなく _target/debug/hello_cargo_ （Windowsでは _target\debug\hello_cargo.exe_ ）に作成します。
デフォルトのビルドがデバッグビルドであるため、Cargoはバイナリを _debug_ というディレクトリに配置します。
この実行可能ファイルは次のコマンドで実行できます：

<!--
```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
```console
$ ./target/debug/hello_cargo # または、Windowsの場合 .\target\debug\hello_cargo.exe
Hello, world!
```

<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: _Cargo.lock_. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
うまくいけば、`Hello, world!` がターミナルに表示されるはずです。
`cargo build` を初めて実行すると、Cargoはもう一つ新しいファイルをトップレベルに作成します：_Cargo.lock_ です。
このファイルはプロジェクト内の依存関係の正確なバージョンを追跡します。
このプロジェクトには依存関係がないため、ファイルの中身は薄いです。
このファイルを手動で変更する必要はなく、Cargoがその内容を管理してくれます。

<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resultant executable all in one command:
-->
先ほどは `cargo build` でプロジェクトをビルドし、`./target/debug/hello_cargo` で実行しましたが、
`cargo run` を使うことで、コードをコンパイルし、その実行可能ファイルを実行するまでをすべて1つのコマンドで行えます。

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

<!--
Using `cargo run` is more convenient than having to remember to run `cargo
build` and then use the whole path to the binary, so most developers use `cargo
run`.
-->
`cargo run` を使う方が、`cargo build` を忘れずに実行したうえでバイナリへのパス全体を打ち込むよりも便利なため、
ほとんどの開発者は `cargo run` を使用します。

<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it didn’t
rebuild but just ran the binary. If you had modified your source code, Cargo
would have rebuilt the project before running it, and you would have seen this
output:
-->
今回はCargoが`hello_cargo`をコンパイルしていることを示す出力が表示されなかったことに注目してください。
Cargoはファイルが変更されていないことを検出したため、再ビルドせずに単にバイナリを実行したのです。
もしソースコードを変更していた場合、Cargoはプロジェクトを再ビルドしてから実行したため、次のような出力が表示されていたでしょう：

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
Cargoには`cargo check`というコマンドもあります。
このコマンドは、コードのコンパイルが通るかを素早く確認しますが、実行可能ファイルは生成しません。

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build` because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process of letting you know if your project is still compiling! As
such, many Rustaceans run `cargo check` periodically as they write their
program to make sure it compiles. Then they run `cargo build` when they’re
ready to use the executable.
-->
実行可能ファイルを生成しない理由は何でしょうか？
多くの場合、`cargo check`は実行可能ファイルの生成ステップを省略するため、`cargo build`よりもはるかに高速です。
コードを書きながら頻繁に作業内容をチェックしたい場合、`cargo check`を使うことで、プロジェクトがまだコンパイルできるかを確認する過程を速くできます！
そのため、多くのRustaceanたちは、プログラムを書いている最中に定期的に`cargo check`を実行してコンパイルが通ることを確認します。
そして、実行可能ファイルを使う準備ができた時に`cargo build`を実行します。

<!--
Let’s recap what we’ve learned so far about Cargo:
-->
私たちがCargoについて学んできたことをおさらいしましょう。

<!--
- We can create a project using `cargo new`.
- We can build a project using `cargo build`.
- We can build and run a project in one step using `cargo run`.
- We can build a project without producing a binary to check for errors using
  `cargo check`.
- Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the _target/debug_ directory.
-->
- `cargo new`を使ってプロジェクトを作成できる。
- `cargo build`を使ってプロジェクトをビルドできる。
- `cargo run`を使って、プロジェクトのビルドと実行を一度に行える。
- `cargo check`を使って、バイナリを生成せずにプロジェクトをビルドし、エラーをチェックできる。
- ビルド結果は、コードと同じディレクトリではなく、 _target/debug_ ディレクトリに保存される。

<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
Cargoを使用する追加の利点は、どのオペレーティングシステムにおいてもコマンドが同じであることです。
そのため、これ以降はLinuxやmacOSとWindowsについて特定の指示を行うことはありません。

<!--
### Building for Release
-->
### リリース用にビルドする

<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in _target/release_ instead of _target/debug_. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in _target/release_.
-->
プロジェクトを最終的にリリースする準備が整ったら、`cargo build --release`を使用して最適化ありでコンパイルできます。
このコマンドは実行可能ファイルを _target/debug_ ではなく _target/release_ の中に作成します。
最適化によりRustコードは速く実行されますが、最適化を有効にするとコンパイル時間が長くなります。
これが2つの異なるプロファイルが用意されている理由です。
1つは開発用で、素早く頻繁に再ビルドしたい場合に適しており、もう一つはユーザー向けの最終プログラムを生成するためのもので、頻繁には再ビルドされず、生成されたプログラムは可能な限り高速に実行されます。
コードの実行時間をベンチマークする場合は、`cargo build --release`を実行し、 _target/release_ の実行可能ファイルでベンチマークを行うようにしてください。

<!--
### Cargo as Convention
-->
### 規約としてのCargo

<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
Once programs grow to multiple files or need a dependency, it’s much easier to
let Cargo coordinate the build.
-->
単純なプロジェクトでは、Cargoは`rustc`を使うのに比べてあまり大きな価値を提供しませんが、プログラムが複雑になるにつれてその真価が発揮されます。
プログラムが複数のファイルに増えたり、依存関係が必要になったりした場合、Cargoにビルドを調整させる方がずっと簡単です。

<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
*hello_cargo* プロジェクトは単純ですが、これからのRustのキャリアで使う実際のツール群の多くをすでに使用しています。
実際、どのような既存のプロジェクトで作業する場合でも、以下のコマンドを使ってGitでコードをチェックアウトし、そのプロジェクトのディレクトリに移動してビルドできます。

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

<!--
For more information about Cargo, check out [its documentation][cargo].
-->
Cargoに関するより詳しい情報については、[公式ドキュメント][cargo]をご覧ください。

<!--
## Summary
-->
## まとめ

<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
Rustの旅の順調なスタートを切れましたね！この章では次のことを学びました。

<!--
- Install the latest stable version of Rust using `rustup`
- Update to a newer Rust version
- Open locally installed documentation
- Write and run a “Hello, world!” program using `rustc` directly
- Create and run a new project using the conventions of Cargo
-->
- `rustup`を使って最新の安定版Rustをインストールする
- より新しいRustのバージョンにアップデートする
- ローカルにインストールされたドキュメントを開く
- `rustc`を直接使用して「Hello, world!」プログラムを作成して実行する
- Cargoの規約に従って新しいプロジェクトを作成して実行する

<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
Rustコードの読み書きに慣れるために、もっと実践的なプログラムを作成する良いタイミングですね。
そこで、2章では「数当てゲーム」プログラムを作成します。
もしRustでの一般的なプログラミングの概念を学ぶことから始めたい場合は、3章を先に読んでから2章に戻ると良いでしょう。

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
